import 'dart:math';
import '../models/question_model.dart';
import '../models/score_model.dart';
import 'supabase_service.dart';

class QuizService {
  static Future<List<QuestionModel>> getQuizQuestions({
    required String courseId,
    required Difficulty difficulty,
  }) async {
    final questionCount = _getQuestionCount(difficulty);

    final questionsData = await SupabaseService.getQuestions(
      courseId: courseId,
      difficulty: difficulty.name,
    );

    final questions = questionsData
        .map((data) => QuestionModel.fromJson(data))
        .toList();

    // Shuffle questions and limit to required count
    questions.shuffle();
    final selectedQuestions = questions.take(questionCount).toList();

    // Shuffle options for each question
    for (var question in selectedQuestions) {
      _shuffleQuestionOptions(question);
    }

    return selectedQuestions;
  }

  static int _getQuestionCount(Difficulty difficulty) {
    switch (difficulty) {
      case Difficulty.easy:
        return 15;
      case Difficulty.intermediate:
        return 25;
      case Difficulty.advanced:
        return 50;
    }
  }

  static void _shuffleQuestionOptions(QuestionModel question) {
    final correctAnswer = question.correctAnswer;
    final correctIndex = ['A', 'B', 'C', 'D'].indexOf(correctAnswer);
    final correctOption = question.options[correctIndex];

    final shuffledOptions = List<String>.from(question.options);
    shuffledOptions.shuffle();

    // Update the correct answer based on new position
    final newCorrectIndex = shuffledOptions.indexOf(correctOption);
    final newCorrectAnswer = ['A', 'B', 'C', 'D'][newCorrectIndex];

    // Note: In a real implementation, you'd need to modify the question model
    // to handle dynamic option shuffling. For simplicity, we'll keep the original structure.
  }

  static Future<ScoreModel> saveQuizResult({
    required String userId,
    required String courseId,
    required Difficulty difficulty,
    required int score,
    required int totalQuestions,
  }) async {
    final pointsEarned = score; // 1 point per correct answer

    await SupabaseService.saveScore(
      userId: userId,
      courseId: courseId,
      difficulty: difficulty.name,
      score: score,
      totalQuestions: totalQuestions,
      pointsEarned: pointsEarned,
    );

    return ScoreModel(
      id: '', // Will be generated by database
      userId: userId,
      courseId: courseId,
      difficulty: difficulty,
      score: score,
      totalQuestions: totalQuestions,
      pointsEarned: pointsEarned,
      completedAt: DateTime.now(),
    );
  }

  static int calculateScore(List<String> userAnswers, List<QuestionModel> questions) {
    int correctCount = 0;
    for (int i = 0; i < userAnswers.length && i < questions.length; i++) {
      if (userAnswers[i] == questions[i].correctAnswer) {
        correctCount++;
      }
    }
    return correctCount;
  }
}